# aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
snippet a; "append(slice, value) \n"
append(${1:<slice>}, ${2:<value>})
endsnippet

snippet av "a = append(a, value) \n"
${1:<slice>} = append($1, ${2:<value>})
endsnippet

snippet ar "a = append(a, value) \n"
${1:<slice>} = append($1[:${2:<index>}], $1[$2+1:]...)
endsnippet

snippet aa "a[k] = value \n"
${1:<array>}[ ${2:<index>} ] = ${3:<value>}
endsnippet




# bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
snippet b; "break "
break 
endsnippet



# cccccccccccccccccccccccccccccccc
#snippet cn "chan Type"
#chan ${0:<type>}
#endsnippet

#snippet case "case ...:"
#case ${1:<value>}:
#	${0:${VISUAL}}
#endsnippet
snippet c: "case ...: \n"
case ${1:<value>}:
	${2:<content>}
endsnippet

snippet c; "const XXX Type = ... \n"
const ${1:<name>} ${2:<type>} = ${3:<value>}
endsnippet

snippet cs "const ( ... \n )"
const (
	${1:<name>} ${2:<type>} = ${3:<value>}
)
endsnippet

snippet ct "continue"
continue 
endsnippet

snippet cp "continue"
copy(${1:<dst>},${2:<src>})
endsnippet



# dddddddddddddddddddddddddddddddd
#snippet default "default: ..."
#default:
#	${0:${VISUAL}}
#endsnippet
#snippet d: "default: ..."
#default:
#	${0:${VISUAL}}
#endsnippet

snippet d; "defer someFunction() \n"
defer ${1:<do>}
endsnippet

snippet df "defer someFunction() \n"
defer ${1:func}(${2})
endsnippet

snippet dd "defer func() { ... }"
defer func() {
	${0:${VISUAL}}
}()
endsnippet

snippet dr
defer func() {
	if err := recover(); err != nil {
		${0:${VISUAL}}
	}
}()
endsnippet

snippet dl "delete(<map>, key"
delete(${1:<map>}, "${2:<key>}")
endsnippet



# eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
#snippet e; "else { ... }"
#else {
#	${0:${VISUAL}}
#}
#endsnippet

snippet ee "if err := statement; err != nil { ... }"
if err := ${1:<condition>}; err != nil {
}
endsnippet

snippet ep "errors.Wrap( ... , ... ) \n"
errors.Wrap(${1:<err>}, "${2:<message>}")
endsnippet

snippet ef "errors.Wrapf( ... , ... , ... ) \n"
errors.Wrapf(${1:<err>}, "${2:<message %v>}", ${3:<args...>})
endsnippet



# ffffffffffffffffffffffffffffffff
snippet fo "fallthrough"
fallthrough
endsnippet

snippet f; "for ... { ... }"
for ${0} {
}
endsnippet

snippet fi "for 0..N-1 { ... }"
for ${2:i} := ${3:0}; $2 < ${1:N}; $2++ {
}
endsnippet

snippet fI "for 0..N-1 { ... }"
$2 := ${3:0}
for ; ${2:i} < ${1:N}; $2++ {
}
endsnippet

snippet fj "for 0..N-1 { ... }"
for ${2:j} := ${3:0}; $2 < ${1:N}; $2++ {
}
endsnippet

snippet fJ "for 0..N-1 { ... }"
$2 := ${3:0}
for ; ${2:j} < ${1:N}; $2++ {
}
endsnippet

snippet fb "for N-1..0 { ... }"
for ${2:i} := ${1:N}; ${3:0} < $2 ; $2-- {
}
endsnippet

snippet fB "for N-1..0 { ... }"
$2 := ${1:N}
for ; ${3:0} < ${2:i} ; $2-- {
}
endsnippet

snippet fr "for k, v := range items { ... }"
for ${0:_, v} := range ${1:`!v matchstr(getline(search("\w*s.*=", "b")), '\w*s')`} {
}
endsnippet

snippet fR "for k, v := range items { ... }"
for ${0:k, v} := range ${1:<gather>} {
}
endsnippet

#snippet func "func Function(...) [error] { ... }"
#func ${1:<name>}(${2:<params>})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {
#	${0:${VISUAL}}
#}
#endsnippet
snippet fc "func Function(...) [error] { ... }"

// $1 
func ${1:<name>}(${2}) (${0}) {
}
endsnippet

snippet ft "fmt.Print(...) \n"
fmt.Print("${1:${VISUAL}}")
endsnippet

#fmt.Printf("$1 = %+v\n", ${1:${VISUAL}})
snippet ff "fmt.Printf(...) \n"
fmt.Printf("\n========== $1 >>>>>>>>>>\n$1 = %+v\n========== $1 <<<<<<<<<<\n\n", ${1:${VISUAL}})
endsnippet

snippet fn "fmt.Println(...) \n"
fmt.Println("${1:${VISUAL}}")
endsnippet

snippet fe "fmt.Errorf(...) \n"
fmt.Errorf("${1:${VISUAL}}")
endsnippet

snippet fw "fmt.Errorf(%w, err) \n"
fmt.Errorf("${1:message}: %w", ${2:${VISUAL:err}})
endsnippet

snippet fs "fmt.Sprintf(...)"
fmt.Sprintf("${1:%s}", ${2:<variate>})
endsnippet




# gggggggggggggggggggggggggggggggg
snippet go "go someFunc(...) \n"
go ${1:<name>}(${0})
endsnippet

snippet gd "go func() { ... }() \n"
go func() {
	${0:${VISUAL}}
}()
endsnippet



# hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

# iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
snippet if "if ... { ... }"
if ${0:flag} {
}
endsnippet

snippet ie "if err != nil { ... \n }"
if err != nil {
	${0:<do err>}
} 
endsnippet

snippet io "if !ok { ... \n }"
if !ok {
	${0:<do err>}
} 
endsnippet



# jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
snippet jm "json.Marshal()"
$1Jsonb, err := json.Marshal(${1:<Struct>})
if err != nil {
	return ${0:err}
}
endsnippet

snippet ju "json.Unmarshal()"
if err := json.Unmarshal(${2:$1Jsonb}, &${1:<Struct>}); err != nil {
	return ${0:err}
}
endsnippet

# kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk

# llllllllllllllllllllllllllllllll
snippet lf "log.Printf(...) \n"
log.Printf("${1:${VISUAL}} = %+v\n", $1)
endsnippet

snippet ln "log.Println(...) \n"
log.Println("${0}")
endsnippet



# mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
#snippet mp "map[Type]Type \n"
#map[${1:string}]${2:string}
#endsnippet

snippet mv "v := make(Type, size) \n"
${1:<name>} := make( ${2:<type>} ,  ${3:0, 10} )
endsnippet

#snippet mi "func main() { ... }"
#func main() {
#	${0:${VISUAL}}
#}
#endsnippet

#snippet meth "func (self Type) Method(...) [error] { ... }"
#func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
#	${0:${VISUAL}}
#}
#endsnippet
snippet mt "func (self Type) Method(...) [error] { ... }"
func (`!p snip.rv = get_head(t[1],1)` *${1:<type>}) ${2:<name>}(${3}) (${0}) {
}
endsnippet



# nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn

snippet nv "v := new(Type) \n"
${1:<name>} := new(${2:<type>})
endsnippet

# oooooooooooooooooooooooooooooooo

# pppppppppppppppppppppppppppppppp
#snippet pk "package ..."
#// Package $1 provides ${2:...}
#package ${1:main}
#endsnippet

snippet pn "panic()"
panic(${0:"msg"})
endsnippet



# qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq



# rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
snippet rt "return"
return ${0}
endsnippet



# ssssssssssssssssssssssssssssssss
snippet ss "string.Split()"
${4:sp} := strings.Split(${1:<src>}, "${2:sep}")[${3:0}]
endsnippet

snippet sS "string.Split()"
${3:splits} := strings.Split(${1:<src>}, "${2:sep}")
endsnippet

snippet sl "select { case a := <-chan: ... }"
select {
case ${1:v} := <-${2:<chan>}:
	${0}
}
endsnippet

snippet sw "switch x { ... }"
switch ${1:<variate>} {
case ${2:<value>}:
	${0:<content>}
default:
}
endsnippet



# tttttttttttttttttttttttttttttttt
snippet tf "type I interface { ... \n }"

// $1
type ${1:<interface>} interface {
}
endsnippet

snippet ts "type T struct { ... \n }"

// $1
type ${1:<type>} struct {
}
endsnippet

snippet ta "type assertion"
${1:<variate>}, ok := ${2:<interface>}.( ${3:<type>} )
if !ok {
	${4:<handle>}
}
endsnippet



# uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu



# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
snippet v; "var x Type [= ...] \n"
var ${1:<name>} ${0:<type>}
endsnippet

snippet vs "var ( ... ) \n"
var (
	${1:<name>} ${0:<type>} 
)
endsnippet

snippet v: "v := value"
${1:<variable>} := ${0:<value>}
endsnippet

snippet vv "v = value \n"
${1:<variable>} = ${0:<value>}
endsnippet

# wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

# xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

# zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

# ################################
#snippet :; "field : value,"
#${1:<field>} : ${2:<value>},
#endsnippet


global !p

import re

# Automatically wrap return types with parentheses

def get_head(str,lent):
	s = str.lower()
	return s[0:lent]

def set_return(str):
	slic = str.split(",")
	lengt = len(slic)
	res = ""
	fl = 0
	for e in slic:
		if e.lstrip().rstrip() == "error":
			if fl != 0:
				res = res + ", "
			else:
				fl = 1
			res = res + "nil"
		elif e != "":
			if fl != 0:
				res = res + ", "
			else:
				fl = 1
			res = res + "<???>"
		else:
			res = ""
	return res

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal
