# aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
snippet a; "append(slice, value) \n"
append(${1:<slice>}, ${2:<value>})
${0}
endsnippet

snippet av "a = append(a, value) \n"
${1:<slice>} = append($1, ${2:<value>})
${0}
endsnippet




# bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
snippet b; "break "
break 
endsnippet



# cccccccccccccccccccccccccccccccc
snippet cn "chan Type"
chan ${0:<type>}
endsnippet

#snippet case "case ...:"
#case ${1:<value>}:
#	${0:${VISUAL}}
#endsnippet
snippet c: "case ...: \n"
case ${1:<value>}:
	${2:<content>}
${0}
endsnippet

snippet c; "const XXX Type = ... \n"
const ${1:<name>} ${2:<type>} = ${3:<value>}
${0}
endsnippet

snippet cs "const ( ... \n )"
const (
	${1:<name>} ${2:<type>} = ${3:<value>}
	${0}
)
endsnippet

snippet ct "continue"
continue 
endsnippet



# dddddddddddddddddddddddddddddddd
#snippet default "default: ..."
#default:
#	${0:${VISUAL}}
#endsnippet
snippet d: "default: ..."
default:
	${0:${VISUAL}}
endsnippet

snippet d; "defer someFunction() \n"
defer ${1:<do>}
${0}
endsnippet

snippet df "defer someFunction() \n"
defer ${1:func}(${2})
${0}
endsnippet

snippet dd "defer func() { ... }"
defer func() {
	${0:${VISUAL}}
}()
endsnippet

snippet dr
defer func() {
	if err := recover(); err != nil {
		${0:${VISUAL}}
	}
}()
endsnippet



# eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
snippet e; "else { ... }"
else {
	${0:${VISUAL}}
}
endsnippet

snippet ee "if err := statement; err != nil { ... }"
if err := ${1:<condition>}; err != nil {
	${0:${VISUAL}}
}
endsnippet

snippet ep "errors.Wrap( ... , ... ) \n"
errors.Wrap(${1:<err>}, "${2:<message>}")
${0}
endsnippet

snippet ef "errors.Wrapf( ... , ... , ... ) \n"
errors.Wrapf(${1:<err>}, "${2:<message %v>}", ${3:<args...>})
${0}
endsnippet



# ffffffffffffffffffffffffffffffff
snippet fo "fallthrough"
fallthrough
endsnippet

snippet f; "for ... { ... }"
for ${1} {
	${0:${VISUAL}}
}
endsnippet

snippet fi "for 0..N-1 { ... }"
for ${1:i} := 0; $1 < ${2:N}; $1++ {
	${0:${VISUAL}}
}
endsnippet

snippet fr "for k, v := range items { ... }"
for ${2:k, v} := range ${1:<gather>} {
	${0:${VISUAL}}
}
endsnippet

#snippet func "func Function(...) [error] { ... }"
#func ${1:<name>}(${2:<params>})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {
#	${0:${VISUAL}}
#}
#endsnippet
snippet fc "func Function(...) [error] { ... }"
func ${1:<name>}(${2}) ${3} {
	${0:${VISUAL}}
}
endsnippet

snippet ft "fmt.Print(...) \n"
fmt.Print("${1:${VISUAL}}")
${0}
endsnippet

#fmt.Printf("$1 = %+v\n", ${1:${VISUAL}})
snippet ff "fmt.Printf(...) \n"
fmt.Printf("\n========== $1 >>>>>>>>>>\n$1 = %+v\n========== $1 <<<<<<<<<<\n\n", ${1:${VISUAL}})
${0}
endsnippet

snippet fn "fmt.Println(...) \n"
fmt.Println("${1:${VISUAL}}")
${0}
endsnippet

snippet fe "fmt.Errorf(...) \n"
fmt.Errorf("${1:${VISUAL}}")
${0}
endsnippet

snippet fw "fmt.Errorf(%w, err) \n"
fmt.Errorf("${1:message}: %w", ${2:${VISUAL:err}})
${0}
endsnippet

snippet fs "fmt.Sprintf(...)"
fmt.Sprintf("%${1:s}", ${2:<variate>})
endsnippet




# gggggggggggggggggggggggggggggggg
snippet go "go someFunc(...) \n"
go ${1:<name>}(${2})
${0}
endsnippet

snippet gd "go func() { ... }() \n"
go func() {
	${1:${VISUAL}}
}()
${0}
endsnippet



# hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

# iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
snippet if "if ... { ... }"
if ${1:<condition>} {
	${0:${VISUAL}}
}
endsnippet

snippet ie "if err != nil { ... \n }"
if err != nil {
	${1:<do err>}
	${0}
} 
endsnippet

snippet io "if !ok { ... \n }"
if !ok {
	${1:<do err>}
	${0}
} 
endsnippet



# jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj

# kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk

# llllllllllllllllllllllllllllllll
snippet lf "log.Printf(...) \n"
log.Printf("${1:${VISUAL}} = %+v\n", $1)
${0}
endsnippet

snippet ln "log.Println(...) \n"
log.Println("${1:${VISUAL}}")
${0}
endsnippet



# mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
snippet mp "map[Type]Type \n"
map[${1:string}]${2:string}
${0}
endsnippet

snippet mv "v := make(Type, size) \n"
${1:<name>} := make(${2:<type>}, ${3:<extra>})
${0}
endsnippet

snippet mi "func main() { ... }"
func main() {
	${0:${VISUAL}}
}
endsnippet

#snippet meth "func (self Type) Method(...) [error] { ... }"
#func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
#	${0:${VISUAL}}
#}
#endsnippet
snippet mt "func (self Type) Method(...) [error] { ... }"
func (${1:<receiver>} ${2:<type>}) ${3:<name>}(${4})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
	${0:${VISUAL}}
}
endsnippet



# nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn

# oooooooooooooooooooooooooooooooo

# pppppppppppppppppppppppppppppppp
snippet pk "package ..."
// Package $1 provides ${2:...}
package ${1:main}
${0}
endsnippet

snippet pn "panic()"
panic(${0:"msg"})
endsnippet



# qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq



# rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
snippet rt "return"
return ${0:${VISUAL}}
endsnippet



# ssssssssssssssssssssssssssssssss
snippet sl "select { case a := <-chan: ... }"
select {
case ${1:v} := <-${2:<chan>}:
	${0}
}
endsnippet

snippet sw "switch x { ... }"
switch ${1:<variate>} {
case ${2:<value>}:
	${0}
}
endsnippet



# tttttttttttttttttttttttttttttttt
snippet tf "type I interface { ... \n }"
type ${1:<interface>} interface {
	${0:<methods>}
}
endsnippet

snippet ts "type T struct { ... \n }"
type ${1:<type>} struct {
	${0:<field>}
}
endsnippet



# uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu



# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
snippet v; "var x Type [= ...] \n"
var ${1:<name>} ${2:<type>} = ${3:<value>}
${0}
endsnippet

snippet vs "var ( ... ) \n"
var (
	${1:<name>} ${2:<type>}${3: = ${4:<value>}}
	${0}
)
endsnippet

snippet v: "v := value"
${1:<variable>} := ${0:<value>}
endsnippet

snippet vv "v = value \n"
${1:<variable>} = ${2:<value>}
${0}
endsnippet

# wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

# xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

# zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz

# ################################
snippet :; "field : value,"
${1:<field>} : ${2:<value>},
endsnippet


global !p

import re

# Automatically wrap return types with parentheses

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal
